{"ast":null,"code":"import { useReducer, useRef, useEffect, useMemo, useLayoutEffect, useContext } from 'react';\nimport invariant from 'invariant';\nimport { useReduxContext as useDefaultReduxContext } from './useReduxContext';\nimport Subscription from '../utils/Subscription';\nimport { ReactReduxContext } from '../components/Context'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\nfunction useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {\n  var _useReducer = useReducer(function (s) {\n      return s + 1;\n    }, 0),\n    forceRender = _useReducer[1];\n  var subscription = useMemo(function () {\n    return new Subscription(store, contextSub);\n  }, [store, contextSub]);\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef();\n  var latestSelectedState = useRef();\n  var selectedState;\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(store.getState());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    var errorMessage = \"An error occured while selecting the store state: \" + err.message + \".\";\n    if (latestSubscriptionCallbackError.current) {\n      errorMessage += \"\\nThe error may be correlated with this previous error:\\n\" + latestSubscriptionCallbackError.current.stack + \"\\n\\nOriginal stack trace:\";\n    }\n    throw new Error(errorMessage);\n  }\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(store.getState());\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n      forceRender({});\n    }\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    return function () {\n      return subscription.tryUnsubscribe();\n    };\n  }, [store, subscription]);\n  return selectedState;\n}\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {Function} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\n\nexport function createSelectorHook(context) {\n  if (context === void 0) {\n    context = ReactReduxContext;\n  }\n  var useReduxContext = context === ReactReduxContext ? useDefaultReduxContext : function () {\n    return useContext(context);\n  };\n  return function useSelector(selector, equalityFn) {\n    if (equalityFn === void 0) {\n      equalityFn = refEquality;\n    }\n    invariant(selector, \"You must pass a selector to useSelectors\");\n    var _useReduxContext = useReduxContext(),\n      store = _useReduxContext.store,\n      contextSub = _useReduxContext.subscription;\n    return useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);\n  };\n}\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\n\nexport var useSelector = createSelectorHook();","map":{"version":3,"names":["useReducer","useRef","useEffect","useMemo","useLayoutEffect","useContext","invariant","useReduxContext","useDefaultReduxContext","Subscription","ReactReduxContext","useIsomorphicLayoutEffect","window","refEquality","a","b","useSelectorWithStoreAndSubscription","selector","equalityFn","store","contextSub","_useReducer","s","forceRender","subscription","latestSubscriptionCallbackError","latestSelector","latestSelectedState","selectedState","current","getState","err","errorMessage","message","stack","Error","undefined","checkForUpdates","newSelectedState","onStateChange","trySubscribe","tryUnsubscribe","createSelectorHook","context","useSelector","_useReduxContext"],"sources":["C:/Kuliah/Semester 6/Topik Khusus/MovieStore/client/node_modules/react-redux/es/hooks/useSelector.js"],"sourcesContent":["import { useReducer, useRef, useEffect, useMemo, useLayoutEffect, useContext } from 'react';\nimport invariant from 'invariant';\nimport { useReduxContext as useDefaultReduxContext } from './useReduxContext';\nimport Subscription from '../utils/Subscription';\nimport { ReactReduxContext } from '../components/Context'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n\nfunction useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {\n  var _useReducer = useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      forceRender = _useReducer[1];\n\n  var subscription = useMemo(function () {\n    return new Subscription(store, contextSub);\n  }, [store, contextSub]);\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef();\n  var latestSelectedState = useRef();\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(store.getState());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    var errorMessage = \"An error occured while selecting the store state: \" + err.message + \".\";\n\n    if (latestSubscriptionCallbackError.current) {\n      errorMessage += \"\\nThe error may be correlated with this previous error:\\n\" + latestSubscriptionCallbackError.current.stack + \"\\n\\nOriginal stack trace:\";\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(store.getState());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender({});\n    }\n\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    return function () {\n      return subscription.tryUnsubscribe();\n    };\n  }, [store, subscription]);\n  return selectedState;\n}\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {Function} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\n\n\nexport function createSelectorHook(context) {\n  if (context === void 0) {\n    context = ReactReduxContext;\n  }\n\n  var useReduxContext = context === ReactReduxContext ? useDefaultReduxContext : function () {\n    return useContext(context);\n  };\n  return function useSelector(selector, equalityFn) {\n    if (equalityFn === void 0) {\n      equalityFn = refEquality;\n    }\n\n    invariant(selector, \"You must pass a selector to useSelectors\");\n\n    var _useReduxContext = useReduxContext(),\n        store = _useReduxContext.store,\n        contextSub = _useReduxContext.subscription;\n\n    return useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);\n  };\n}\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\n\nexport var useSelector = createSelectorHook();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}